#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# spark
# https://github.com/holman/spark
#
# Generates sparklines for a set of data.
#
# Here's a a good web-based sparkline generator that was a bit of inspiration
# for spark:
#
#   https://datacollective.org/sparkblocks
#
# spark takes a comma-separated list of data and then prints a sparkline out of
# it.
#
# Examples:
#
#   spark 1,5,22,13,53
#   # => ▁▁▃▂▇
#
#   spark 0,30,55,80,33,150
#   # => ▁▂▃▅▂▇
#
#   spark -h
#   # => Prints the spark help text.

import getopt
import fileinput
import os
import re
import sys


def help():
    """
    Prints the help text for spark.

    Returns nothing.
    """

    print """

  USAGE:
    spark [comma,separated,value,list]

  EXAMPLES:
    spark 1,5,22,13,53
    ▁▁▃▂▇
    spark 0,30,55,80,33,150
    ▁▂▃▅▂▇
"""
    sys.exit(0)


def splitlines(lines):
    """
    split lines from the iterator yielding numbers
    """
    for line in lines:
        source = line.strip()
        split = re.split("[,\s]+", source)
        numbers = [float((x.strip())) for x in split]
        for number in numbers:
            yield number


class Data(object):
    """
    Container class which parses the string data from the
    user and caches all relevant values
    """

    def __init__(self, ticks, numbers, user_min=None, user_max=None):
        self.ticks = ticks           # tick symbols to use
        self.numbers = numbers       # iterator of numbers
        self.bins = len(self.ticks)  # number of buckets or bins
        self.shift = 0               # shift for negative numbers
        self.min = user_min          # possibly user provided min
        self.max = user_max          # possibly user provided max
        self.setup()

    def setup(self):
        if self.max is None:
            self.numbers = list(self.numbers) # Eagerly load.
            self.max = max(self.numbers)
        if self.min is None:
            self.numbers = list(self.numbers) # Eagerly load.
            self.min = min(self.numbers)
        if self.min < 0:
            self.shift = -1 * self.min

        self.range = self.max - self.min
        self.divisor = self.range / (self.bins - 1)
        if self.divisor == 0:
            self.divisor = 1

    def print_ticks(self):
        """
        Iterate over all of our ticks and print them out.

        Returns nothing.
        """
        for number in self.numbers:
            target = (self.shift + number) / self.divisor
            choice = int(target)
            if choice < 0:
                choice = 0
            elif choice >= self.bins:
                choice = self.bins - 1
            sys.stdout.write(self.ticks[choice].encode("utf-8"))
        print


def main():

    # The actual fun characters we are generating in the sparkline.
    ticks = (u"▁", u"▂", u"▃", u"▄", u"▅", u"▆", u"▇", u"█")

    args = sys.argv[1:]

    optlist, args = getopt.getopt(args, ':h', \
            ["chars=", "min=", "max=", "file="])

    file = False
    user_min = None
    user_max = None

    for k, v in optlist:
        if k == "-h":
            help()
        elif k == "--chars":
            if not v:
                help()
            elif re.match("\d+", v):
                size = int(v)
                ticks = ["%s " % x for x in range(1, size + 1)]
        elif k == "--file":
            file= v
        elif k == "--min":
            user_min = int(v)
        elif k == "--max":
            user_max = int(v)

    if file and (user_min is None or user_max is None):
        help()

    source = None
    if len(args) > 0:
        source = splitlines([args[0]])
    else:
        if sys.stdin.isatty():
            help()
        source = splitlines(fileinput.input(file))

    data = Data(ticks, source, user_min=user_min, user_max=user_max)
    data.print_ticks()

if __name__ == "__main__":
    main()
